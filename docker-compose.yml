# snapMULTI Docker Compose
# Hardware profile auto-detected by deploy.sh: minimal | standard | performance

x-logging: &default-logging
  driver: json-file
  options:
    max-size: "10m"
    max-file: "3"

x-security: &default-security
  security_opt:
    - apparmor:unconfined  # Required for D-Bus access
    - no-new-privileges:true
  cap_drop:
    - ALL
  cap_add:
    - DAC_OVERRIDE      # File access as non-root
    - SETUID
    - SETGID

# Resource profiles (set HARDWARE_PROFILE in .env)
x-resources-minimal: &resources-minimal
  deploy:
    resources:
      limits:
        memory: 128M
        cpus: '0.5'
      reservations:
        memory: 64M

x-resources-standard: &resources-standard
  deploy:
    resources:
      limits:
        memory: 256M
        cpus: '1.0'
      reservations:
        memory: 128M

x-resources-performance: &resources-performance
  deploy:
    resources:
      limits:
        memory: 512M
        cpus: '2.0'
      reservations:
        memory: 256M

services:
  snapserver:
    image: lollonet/snapmulti-server:latest
    container_name: snapserver
    hostname: snapmulti
    restart: unless-stopped
    network_mode: host
    <<: *default-security
    read_only: true
    tmpfs:
      - /tmp:size=64M
      - /run:size=64M
    user: "${PUID:-1000}:${PGID:-1000}"
    volumes:
      - ./config/snapserver.conf:/etc/snapserver.conf:ro
      - ./config:/config:ro
      - ./data:/data
      - ./audio:/audio
      - /run/dbus/system_bus_socket:/run/dbus/system_bus_socket
    environment:
      - TZ=${TZ:-Europe/Berlin}
    command: ["snapserver", "-c", "/etc/snapserver.conf"]
    logging: *default-logging
    healthcheck:
      test: ["CMD-SHELL", "pidof snapserver || exit 1"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 15s
    deploy:
      resources:
        limits:
          memory: ${SNAPSERVER_MEM_LIMIT:-256M}
          cpus: '${SNAPSERVER_CPU_LIMIT:-1.0}'
        reservations:
          memory: ${SNAPSERVER_MEM_RESERVE:-128M}

  shairport-sync:
    image: lollonet/snapmulti-airplay:latest
    container_name: shairport-sync
    restart: unless-stopped
    network_mode: host
    <<: *default-security
    read_only: true
    tmpfs:
      - /tmp:size=32M
      - /run:size=32M
    user: "${PUID:-1000}:${PGID:-1000}"
    volumes:
      - ./audio:/audio
      - ./config/shairport-sync.conf:/etc/shairport-sync.conf:ro
      - /run/dbus/system_bus_socket:/run/dbus/system_bus_socket
    environment:
      - TZ=${TZ:-Europe/Berlin}
      - DEVICE_NAME=${AIRPLAY_NAME:-}
    depends_on:
      snapserver:
        condition: service_healthy
    logging: *default-logging
    healthcheck:
      test: ["CMD-SHELL", "pgrep -x shairport-sync && test -p /audio/airplay_fifo || exit 1"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 10s
    deploy:
      resources:
        limits:
          memory: ${AIRPLAY_MEM_LIMIT:-128M}
          cpus: '${AIRPLAY_CPU_LIMIT:-0.5}'
        reservations:
          memory: ${AIRPLAY_MEM_RESERVE:-64M}

  # Spotify Connect — go-librespot with metadata via WebSocket API
  # Open Spotify app → Connect to a device → Select "<hostname> Spotify"
  # Metadata + playback control via meta_go-librespot.py (Snapcast plugin)
  librespot:
    image: ghcr.io/devgianlu/go-librespot:v0.7.0
    container_name: librespot
    restart: unless-stopped
    network_mode: host
    <<: *default-security
    read_only: true
    tmpfs:
      - /tmp:size=32M
      - /config:size=1M       # Credential cache (volatile — re-auth via Spotify app after restart)
    user: "${PUID:-1000}:${PGID:-1000}"
    volumes:
      - ./config/go-librespot.yml:/config/config.yml:ro
      - ./audio:/audio
      - /var/run/dbus:/var/run/dbus
    environment:
      - TZ=${TZ:-Europe/Berlin}
      - SPOTIFY_NAME=${SPOTIFY_NAME:-}
    entrypoint: ["sh", "-c"]
    command:
      - |
        NAME="$${SPOTIFY_NAME:-$$(hostname) Spotify}"
        NAME=$$(printf '%s' "$$NAME" | tr -cd 'A-Za-z0-9 ._-')
        [ -z "$$NAME" ] && NAME="snapMULTI Spotify"
        sed "s/^device_name:.*/device_name: \"$$NAME\"/" /config/config.yml > /tmp/config.yml
        # Hold FIFO open (read-write) so snapserver keeps its reader active;
        # without this, go-librespot's O_NONBLOCK write open gets ENXIO
        exec 3<>/audio/spotify_fifo
        exec go-librespot --config_dir /tmp
    depends_on:
      snapserver:
        condition: service_healthy
    logging: *default-logging
    healthcheck:
      test: ["CMD-SHELL", "pgrep go-librespot && wget -q --spider http://127.0.0.1:24879/ || exit 1"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 15s
    deploy:
      resources:
        limits:
          memory: ${SPOTIFY_MEM_LIMIT:-128M}
          cpus: '${SPOTIFY_CPU_LIMIT:-0.5}'
        reservations:
          memory: ${SPOTIFY_MEM_RESERVE:-64M}

  mympd:
    image: ghcr.io/jcorporation/mympd/mympd:latest
    container_name: mympd
    restart: unless-stopped
    network_mode: host
    security_opt:
      - no-new-privileges:true
    cap_drop:
      - ALL
    read_only: true
    tmpfs:
      - /tmp:size=32M
    user: "${PUID:-1000}:${PGID:-1000}"
    volumes:
      - ./mympd/workdir:/var/lib/mympd
      - ./mympd/cachedir:/var/cache/mympd
      - ${MUSIC_PATH:-/media/music}:/music:ro
      - ./mpd/playlists:/playlists:ro
    environment:
      - TZ=${TZ:-Europe/Berlin}
      - MYMPD_HTTP_PORT=8180
      - MYMPD_SSL=false
    depends_on:
      mpd:
        condition: service_healthy
    logging: *default-logging
    healthcheck:
      test: ["CMD-SHELL", "wget -q --spider http://127.0.0.1:8180/ || exit 1"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: ${MPD_START_PERIOD:-60s}
    deploy:
      resources:
        limits:
          memory: ${MYMPD_MEM_LIMIT:-128M}
          cpus: '${MYMPD_CPU_LIMIT:-0.5}'
        reservations:
          memory: ${MYMPD_MEM_RESERVE:-64M}

  mpd:
    image: lollonet/snapmulti-mpd:latest
    container_name: mpd
    restart: unless-stopped
    network_mode: host
    security_opt:
      - no-new-privileges:true
    cap_drop:
      - ALL
    read_only: true
    tmpfs:
      - /tmp:size=64M
      - /run:size=32M
    user: "${PUID:-1000}:${PGID:-1000}"
    volumes:
      - ./audio:/audio
      - ${MUSIC_PATH:-/media/music}:/music:ro
      - ./config/mpd.conf:/etc/mpd.conf:ro
      - ./mpd/playlists:/playlists
      - ./mpd/data:/data
    environment:
      - TZ=${TZ:-Europe/Berlin}
    logging: *default-logging
    healthcheck:
      test: ["CMD-SHELL", "echo 'ping' | nc -w 2 127.0.0.1 6600 | grep -q OK || exit 1"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: ${MPD_START_PERIOD:-60s}
    deploy:
      resources:
        limits:
          memory: ${MPD_MEM_LIMIT:-256M}
          cpus: '${MPD_CPU_LIMIT:-1.0}'
        reservations:
          memory: ${MPD_MEM_RESERVE:-128M}

  # Metadata Service — centralized cover art + track info for all streams
  # WebSocket (port 8082): clients subscribe with CLIENT_ID to get their stream's metadata
  # HTTP (port 8083): serves artwork files and metadata.json
  metadata:
    image: lollonet/snapmulti-metadata:latest
    container_name: metadata
    build:
      context: .
      dockerfile: Dockerfile.metadata
    restart: unless-stopped
    network_mode: host
    security_opt:
      - no-new-privileges:true
    cap_drop:
      - ALL
    read_only: true
    tmpfs:
      - /tmp:size=32M
    user: "${PUID:-1000}:${PGID:-1000}"
    environment:
      - TZ=${TZ:-Europe/Berlin}
      - EXTERNAL_HOST=${EXTERNAL_HOST:-}
    volumes:
      - ./artwork:/app/artwork
    healthcheck:
      test: ["CMD", "python3", "-c", "import urllib.request; urllib.request.urlopen('http://127.0.0.1:8083/health', timeout=3)"]
      interval: 30s
      timeout: 5s
      start_period: 10s
      retries: 3
    depends_on:
      snapserver:
        condition: service_healthy
    logging: *default-logging
    deploy:
      resources:
        limits:
          memory: ${METADATA_MEM_LIMIT:-128M}
          cpus: '${METADATA_CPU_LIMIT:-0.5}'
        reservations:
          memory: ${METADATA_MEM_RESERVE:-64M}

  # Tidal Connect - Cast from Tidal app (ARM only: Pi 3/4/5)
  # Open Tidal app → Select device → "<hostname> Tidal"
  # Note: x86_64 not supported - tidal-connect binaries are ARM-only
  tidal-connect:
    image: lollonet/snapmulti-tidal:latest
    container_name: tidal-connect
    network_mode: host
    restart: unless-stopped
    security_opt:
      - no-new-privileges:true
    cap_drop:
      - ALL
    cap_add:
      - DAC_OVERRIDE   # Restore after cap_drop: ALL — root needs it to write FIFOs owned by PUID
    tmpfs:
      - /tmp:size=64M
      - /config:size=1M
    volumes:
      - ./audio:/audio
      - ./config/tidal-asound.conf:/userconfig/asound.conf:ro
      - /var/run/dbus:/var/run/dbus
      - /etc/hostname:/etc/hostname:ro
    environment:
      - TZ=${TZ:-Europe/Berlin}
      - FRIENDLY_NAME=${TIDAL_NAME:-}
      - FORCE_PLAYBACK_DEVICE=default
    depends_on:
      snapserver:
        condition: service_healthy
    logging: *default-logging
    healthcheck:
      test: ["CMD-SHELL", "pgrep -f tidal || exit 1"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 10s
    deploy:
      resources:
        limits:
          memory: ${TIDAL_MEM_LIMIT:-128M}
          cpus: ${TIDAL_CPU_LIMIT:-0.5}
        reservations:
          memory: ${TIDAL_MEM_RESERVE:-64M}
